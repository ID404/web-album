<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>随机图片播放器 - 平滑切换</title>
    <style>
        body {
            background-color: #000000;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            color: white;
        }

        #slideshow-container {
            width: 100%;
            height: 100%;
            position: relative; /* 为内部绝对定位的图片提供参照 */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .slide-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            max-width: 100vw; /* 确保图片宽度不超过视口 */
            max-height: 100vh;/* 确保图片高度不超过视口 */
            object-fit: contain;
            opacity: 0;
            transition: opacity 0.8s ease-in-out; /* 平滑过渡效果 */
        }

        .slide-image.active {
            opacity: 1;
            z-index: 1; /* 确保活动图片在上方 */
        }
        .slide-image.loading-next {
            z-index: 0; /* 预加载的图片在下方 */
        }


        #fullscreen-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.4);
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            z-index: 1000;
            transition: background-color 0.3s ease, color 0.3s ease;
            display: inline-block;
        }

        #fullscreen-btn:hover {
            background-color: rgba(0, 0, 0, 0.6);
            color: rgba(255, 255, 255, 1);
        }

        .loader {
            border: 8px solid #f3f3f3;
            border-radius: 50%;
            border-top: 8px solid #555;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -30px;
            margin-left: -30px;
            z-index: 5; /*确保在图片之上，但按钮之下*/
            display: none; /* 初始隐藏 */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="slideshow-container">
        <img id="image-slot-1" class="slide-image" src="" alt="图片加载中...">
        <img id="image-slot-2" class="slide-image" src="" alt="图片加载中...">
        <div class="loader" id="loader"></div>
    </div>
    <button id="fullscreen-btn">全屏</button>

    <script>
        const imgSlot1 = document.getElementById('image-slot-1');
        const imgSlot2 = document.getElementById('image-slot-2');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const loaderElement = document.getElementById('loader');

        const imageListUrl = '/images/image_list.txt';
        const imageBaseUrl = '/images/';
        const changeInterval = 10000; // 10秒

        let images = [];
        let currentIndex = 0;
        let intervalId = null;

        let currentActiveSlot = imgSlot1; // 当前显示的图片槽
        let nextLoadingSlot = imgSlot2;   // 用于预加载的图片槽

        // 打乱数组
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        async function fetchImageUrls() {
            try {
                const response = await fetch(`${imageListUrl}?t=${new Date().getTime()}`);
                if (!response.ok) throw new Error(`无法加载图片列表: ${response.statusText}`);
                const text = await response.text();
                images = text.split('\n').map(name => name.trim()).filter(name => name.length > 0);

                if (images.length === 0) {
                    handleNoImages();
                    return false;
                }
                shuffleArray(images);
                return true;
            } catch (error) {
                console.error("获取图片列表失败:", error);
                loaderElement.style.display = 'none';
                currentActiveSlot.alt = `加载图片列表失败: ${error.message}`;
                currentActiveSlot.classList.add('active'); // 至少显示错误信息
                return false;
            }
        }

        function handleNoImages() {
            loaderElement.style.display = 'none';
            currentActiveSlot.alt = '图片目录中没有找到图片或列表为空。';
            currentActiveSlot.src = ''; // 清空src
            currentActiveSlot.classList.add('active'); // 显示alt文本
            console.warn("图片列表为空。");
            if (intervalId) clearInterval(intervalId); // 停止切换
        }

        function preloadAndSwitchImage() {
            if (images.length === 0) return;

            loaderElement.style.display = 'block'; // 显示加载器直到下一张图加载完成并切换

            const nextImageIndex = currentIndex % images.length;
            const imageUrl = `${imageBaseUrl}${images[nextImageIndex]}`;

            nextLoadingSlot.classList.remove('active'); // 确保预加载槽不是active
            nextLoadingSlot.classList.add('loading-next');

            nextLoadingSlot.onload = () => {
                currentActiveSlot.classList.remove('active');
                nextLoadingSlot.classList.add('active');
                nextLoadingSlot.classList.remove('loading-next');

                // 交换角色
                const temp = currentActiveSlot;
                currentActiveSlot = nextLoadingSlot;
                nextLoadingSlot = temp;

                loaderElement.style.display = 'none'; // 图片切换完成，隐藏加载器
                currentIndex = (currentIndex + 1) % images.length; // 移到下一张，为下一次preload做准备
            };

            nextLoadingSlot.onerror = () => {
                console.warn(`图片加载失败: ${imageUrl}. 将尝试下一张.`);
                loaderElement.style.display = 'none'; // 即使失败也隐藏加载器
                // 简单地跳过这张图，定时器会在下一次尝试
                currentIndex = (currentIndex + 1) % images.length;
                 // 如果希望错误时立即尝试下一张，可以再次调用 preloadAndSwitchImage()
                 // 但要注意避免在网络持续错误时造成快速循环，可以加个计数器或延迟
            };

            nextLoadingSlot.src = imageUrl;
        }

        async function startSlideshow() {
            loaderElement.style.display = 'block';
            const hasImages = await fetchImageUrls();
            if (!hasImages) return;

            // 初始加载第一张图片到 active slot
            currentActiveSlot.onload = () => {
                currentActiveSlot.classList.add('active');
                loaderElement.style.display = 'none';
                currentIndex = (currentIndex + 1) % images.length; // 指向下一张，供 preload 使用

                // 预加载下一张 (如果只有一张图片，则不需要)
                if (images.length > 1) {
                    preloadAndSwitchImage(); // 开始第一次预加载和后续的切换循环
                } else {
                    // 只有一张图片，不需要定时器切换，但需要确保显示
                    currentActiveSlot.classList.add('active');
                    loaderElement.style.display = 'none';
                }

                // 设置定时器（仅当图片多于一张时）
                if (images.length > 1) {
                    if (intervalId) clearInterval(intervalId);
                    intervalId = setInterval(preloadAndSwitchImage, changeInterval);
                }
            };
            currentActiveSlot.onerror = () => {
                console.error(`初始图片加载失败: ${imageBaseUrl}${images[0]}`);
                loaderElement.style.display = 'none';
                currentActiveSlot.alt = '初始图片加载失败';
                currentActiveSlot.classList.add('active'); // 即使失败也尝试显示alt
            };
            currentActiveSlot.src = `${imageBaseUrl}${images[currentIndex]}`; // 加载第一张
        }


        // 全屏功能
        function toggleFullscreen() {
            // ... (全屏逻辑保持不变) ...
            const docEl = document.documentElement;
            const isInFullscreen = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;

            if (!isInFullscreen) {
                if (docEl.requestFullscreen) docEl.requestFullscreen();
                else if (docEl.mozRequestFullScreen) docEl.mozRequestFullScreen();
                else if (docEl.webkitRequestFullscreen) docEl.webkitRequestFullscreen();
                else if (docEl.msRequestFullscreen) docEl.msRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
            }
        }
        fullscreenBtn.addEventListener('click', toggleFullscreen);

        function handleFullscreenChange() {
            // ... (全屏按钮显隐逻辑保持不变) ...
            const isInFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
            fullscreenBtn.style.display = isInFullscreen ? 'none' : 'inline-block';
            if (!isInFullscreen) fullscreenBtn.textContent = '全屏';
        }
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);

        document.addEventListener('DOMContentLoaded', startSlideshow);
    </script>
</body>
</html>
